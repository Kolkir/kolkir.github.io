<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>C-Vision</title><link href="http://www.c-vision.com.ua/" rel="alternate"></link><link href="http://www.c-vision.com.ua/feeds%5Call.atom.xml" rel="self"></link><id>http://www.c-vision.com.ua/</id><updated>2013-10-31T12:16:00+02:00</updated><entry><title>List of useful C++ macroses and definitions</title><link href="http://www.c-vision.com.ua/list-of-useful-c-macroses-and-definitions.html" rel="alternate"></link><updated>2013-10-31T12:16:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2013-10-31:list-of-useful-c-macroses-and-definitions.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://predef.sourceforge.net/"&gt;http://predef.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>How to make reusable buffer for C++ streaming operations</title><link href="http://www.c-vision.com.ua/how-to-make-reusable-buffer-for-c-streaming-operations.html" rel="alternate"></link><updated>2013-07-23T14:44:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2013-07-23:how-to-make-reusable-buffer-for-c-streaming-operations.html</id><summary type="html">&lt;p&gt;Here is an example how make parsing number in C++ without temporary
string buffer, which sometimes needed when you use std::stringstream.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;streambuf&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;type_traits&amp;gt;

struct mystreambuf : public std::streambuf
{
    mystreambuf(char_type* buffer, std::streamsize bufferLength)
    {
        setg(buffer, buffer, buffer + bufferLength);
    }
protected:
    virtual pos_type seekoff(off_type offset, std::ios_base::seekdir direction, std::ios_base::openmode)
    {
        off_type curpos = gptr() - eback();
        std::streamsize bufferLength = egptr() - eback();
        off_type newpos = -1;

        if(direction == std::ios::cur)
        {
            newpos = curpos + offset;
        }
        else if (direction == std::ios::end)
        {
            newpos = bufferLength - offset;
        }
        else
        {
            newpos = offset;
        }

        setg(eback(), eback() + newpos, egptr());
        return newpos;
    }

    virtual pos_type seekpos(pos_type , std::ios_base::openmode )
    {
        return (std::streampos(std::_BADOFF));
    }
};

int main(int arcg, char* argv[])
{
    auto msg = &amp;quot;123.45&amp;quot;;
    auto length = sizeof(msg);
    std::vector&amp;lt;char&amp;gt; buffer(msg, msg + length);

    mystreambuf streamBuffer(buffer.data(), length);

    std::istream localStream(&amp;amp;streamBuffer);

    double res = 0;
    localStream.seekg(1, localStream.beg);
    localStream &amp;gt;&amp;gt; res;

    localStream.clear();
    localStream.seekg(0, localStream.beg);

    res = 0;
    localStream &amp;gt;&amp;gt; res;

    auto msg2 = &amp;quot;33.5&amp;quot;;
    length = sizeof(msg2);
    buffer.assign(msg2, msg2 + length);

    localStream.clear();
    localStream.seekg(0, localStream.beg);

    res = 0;
    localStream &amp;gt;&amp;gt; res;

    return 0;
}
&lt;/pre&gt;
</summary><category term="C++"></category><category term="parsing"></category><category term="stream"></category></entry><entry><title>CppTask update</title><link href="http://www.c-vision.com.ua/cpptask-update.html" rel="alternate"></link><updated>2013-04-04T11:15:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2013-04-04:cpptask-update.html</id><summary type="html">&lt;p&gt;I've made some refactoring of my CppTask library to improve errors
handling strategy&lt;/p&gt;
</summary><category term="CppTask"></category><category term="Multithreading"></category></entry><entry><title>Canyon CNR-WCAM 820 HD - Disassemble</title><link href="http://www.c-vision.com.ua/canyon-cnr-wcam-820-hd-disassemble.html" rel="alternate"></link><updated>2013-03-08T13:23:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2013-03-08:canyon-cnr-wcam-820-hd-disassemble.html</id><summary type="html">&lt;p&gt;To continue my experiments with my scanner tool, I've need to calibrate
my web camera Canyon CNR-WCAM 820 HD. I've disassembled camera to
measure sensor size, it has 4mm width and 2.5mm height. Also I've found
problems with poorly soldered elements (see sensor photo), and using
sticky tape for compactors.&lt;/p&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6013_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6013_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6012_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6012_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6010_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6010_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6009_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6009_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6008_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6008_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6007_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6007_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6003_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6003_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/camera/IMG_6002_1.jpg"&gt;&lt;img alt="shoot" src="images/camera/IMG_6002_1.jpg" style="width: 300px; height: 230px;" /&gt;&lt;/a&gt;
</summary></entry><entry><title>Camera Calibration Tool now lives on GitHub</title><link href="http://www.c-vision.com.ua/camera-calibration-tool-now-lives-on-github.html" rel="alternate"></link><updated>2013-02-28T12:13:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2013-02-28:camera-calibration-tool-now-lives-on-github.html</id><summary type="html">&lt;p&gt;Camera Calibration Tool sources now lives on GitHub :&lt;a class="reference external" href="https://github.com/Kolkir/calib"&gt;https://github.com/Kolkir/calib&lt;/a&gt; .
I'm now updating this tool to use it with my scanner project so it will have some new features:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Undistorted photo preview&lt;/li&gt;
&lt;li&gt;Measuring camera sensor size (with known focal length)&lt;/li&gt;
&lt;li&gt;Measuring camera focal length (with known sensor size)&lt;/li&gt;
&lt;/ol&gt;
</summary><category term="calibration"></category></entry><entry><title>Home made 3D laser scanner</title><link href="http://www.c-vision.com.ua/home-made-3d-laser-scanner.html" rel="alternate"></link><updated>2013-02-14T22:33:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2013-02-14:home-made-3d-laser-scanner.html</id><summary type="html">&lt;p&gt;I'm developing 3D scanner as hobby project. It's hardware part based on
small 650nm 5mW laser module, 2mpx web camera, servo motor and Arduino.
Corresponding software for PC are developing also. Here are some photos
and video:&lt;/p&gt;
&lt;p&gt;Video how does it works :&lt;/p&gt;
&lt;div class="youtube" align="left"&gt;&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/O0wbReu0ksE" frameborder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;a class="reference external image-reference" href="images/laser/IMG_5625_1.jpg"&gt;&lt;img alt="shoot" src="images/laser/IMG_5625_1.jpg" style="width: 300px; height: 200px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/laser/IMG_5627_1.jpg"&gt;&lt;img alt="shoot" src="images/laser/IMG_5627_1.jpg" style="width: 300px; height: 200px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/laser/IMG_5628_1.jpg"&gt;&lt;img alt="shoot" src="images/laser/IMG_5628_1.jpg" style="width: 300px; height: 200px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/laser/IMG_5631_1.jpg"&gt;&lt;img alt="shoot" src="images/laser/IMG_5631_1.jpg" style="width: 300px; height: 200px;" /&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="images/laser/IMG_5632_1.jpg"&gt;&lt;img alt="shoot" src="images/laser/IMG_5632_1.jpg" style="width: 300px; height: 200px;" /&gt;&lt;/a&gt;
</summary><category term="Laser"></category><category term="Scanner"></category></entry><entry><title>Python script to automate VC++ build</title><link href="http://www.c-vision.com.ua/python-script-to-automate-vc-build.html" rel="alternate"></link><updated>2012-12-21T10:43:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-12-21:python-script-to-automate-vc-build.html</id><summary type="html">&lt;p&gt;Here is example of the Python script which can be used to automate VC++
compilation and build process. It sequentially build VC Solutions and
write short results to console window. If there were errors during
compilation it will show them(only errors) and asks about continuing
general build process.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
buildDirDebug    = &amp;quot;D:\\development\\Debug&amp;quot;
buildDirRelease  = &amp;quot;D:\\development\\Release&amp;quot;

binaryDir = &amp;quot;SourceCode\\Bin&amp;quot;
codeDir   = &amp;quot;SourceCode&amp;quot;
devenv    = &amp;quot;\&amp;quot;C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\Common7\\IDE\\devenv.com\&amp;quot;&amp;quot;
logFile   = &amp;quot;build.log&amp;quot;

# path relative to &amp;quot;codeDir&amp;quot;
solutions = [
&amp;quot;Proj1\solution1.sln&amp;quot;,
&amp;quot;Proj2\solution2.sln&amp;quot;,
&amp;quot;Proj3\solution3.sln&amp;quot;,
]

buildModeDebug   = &amp;quot;Debug&amp;quot;
buildModeRelease = &amp;quot;Release&amp;quot;

#------------------------------------------------------------------------------------------------------

import sys
import subprocess
from threading  import Thread
from Queue import Queue, Empty
import colorama
from colorama import Fore, Back, Style

buildDir  = buildDirDebug
buildMode = buildModeDebug

answer = raw_input('Debug/Release?[d/r]:')
if answer.lower() == &amp;quot;r&amp;quot;:
    buildDir  = buildDirRelease
    buildMode = buildModeRelease

colorama.init()

outEncoding = &amp;quot;cp866&amp;quot;

spaces = &amp;quot;    &amp;quot;

def enqueue_output(out, queue):
    for line in iter(out.readline, b''):
        queue.put(line)
    out.close()

outFile = open(logFile,&amp;quot;wb&amp;quot;)

def RunCommand(strCommand):
    cmd = subprocess.Popen(strCommand, shell=True, bufsize=1, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    q = Queue()
    t = Thread(target=enqueue_output, args=(cmd.stdout, q))
    t.start()

    while True:
        code = cmd.poll()
        try:
            line = q.get_nowait()
        except Empty:
            pass
            #skip
        else:
            outFile.write(line)
            text = line.decode(outEncoding)
            if text.find(&amp;quot;error &amp;quot;) != -1 :
                print(text)
        if (code != None):
            break

    outFile.flush()
    resultStr = &amp;quot;&amp;quot;
    if code != 0:
        for line in cmd.stderr:
            text = line.decode(outEncoding)
            resultStr += &amp;quot;\n&amp;quot; + spaces + spaces + text

    return code == 0, resultStr

def DoCommand(strName, strCommand):
    print(strName + &amp;quot;\n&amp;quot;)
    ok, resStr = RunCommand(strCommand)
    if ok:
        print(spaces + Fore.GREEN + &amp;quot;Done&amp;quot;)
    else:
        print(spaces + Fore.RED + &amp;quot;Failed: &amp;quot; + strCommand)
        print(resStr)

        cont = False
        answer = raw_input('Continue?[y/n]:')
        if answer.lower() == &amp;quot;n&amp;quot;:
            exit(1)

    print(Fore.RESET + Back.RESET + Style.RESET_ALL)

DoCommand(&amp;quot;Clear binaries&amp;quot;, &amp;quot;rmdir /s /q \&amp;quot;&amp;quot; + buildDir + &amp;quot;\\&amp;quot; + binaryDir + &amp;quot;\&amp;quot;&amp;quot;)
DoCommand(&amp;quot;SVN clear&amp;quot;, &amp;quot;\&amp;quot;C:\\Program Files\\TortoiseSVN\\bin\\TortoiseProc.exe\&amp;quot; /command:cleanup /path:\&amp;quot;&amp;quot; + buildDir + &amp;quot;\&amp;quot; /noui /delunversioned /delignored&amp;quot;)
DoCommand(&amp;quot;Creating bin directory&amp;quot;, &amp;quot;mkdir \&amp;quot;&amp;quot; + buildDir + &amp;quot;\\&amp;quot; + binaryDir + &amp;quot;\&amp;quot;&amp;quot;)

for s in solutions:
    DoCommand(&amp;quot;Compile  - &amp;quot; + s, devenv + &amp;quot; \&amp;quot;&amp;quot; + buildDir + &amp;quot;\\&amp;quot; + codeDir + &amp;quot;\\&amp;quot; + s + &amp;quot;\&amp;quot;&amp;quot; + &amp;quot; /rebuild \&amp;quot;&amp;quot; + buildMode + &amp;quot;|x64\&amp;quot;&amp;quot;)

raw_input('Press any key to finish')
&lt;/pre&gt;
</summary></entry><entry><title>DSLR camera simulator</title><link href="http://www.c-vision.com.ua/dslr-camera-simulator.html" rel="alternate"></link><updated>2012-06-21T10:22:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-06-21:dslr-camera-simulator.html</id><summary type="html">&lt;p&gt;I have and idea to create DSLR camera simulator. It should be an
application where user can add different objects to scene and light
sources (for example soft boxes), then move and rotate them. Also there
should be a camera, which user will move too. Camera settings should be
changeable. Also all of this should be presented in 3D mode. And the
main feature will be ray-tracing module which will make rendering
according to the camera settings. Main goal of application will allow
user to play with light and DOF. I think that ray-tracing will be
without material settings and textures.&lt;/p&gt;
</summary></entry><entry><title>CppTask library now with work-stealing task management</title><link href="http://www.c-vision.com.ua/cpptask-library-now-with-work-stealing-task-management.html" rel="alternate"></link><updated>2012-06-05T14:00:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-06-05:cpptask-library-now-with-work-stealing-task-management.html</id><summary type="html">&lt;p&gt;I've released new version of &lt;a class="reference external" href="http://code.google.com/p/cpptask/"&gt;CppTask&lt;/a&gt;library with work-stealing
tasks management.&lt;/p&gt;
</summary></entry><entry><title>Camera Calibration Tool update</title><link href="http://www.c-vision.com.ua/camera-calibration-tool-update.html" rel="alternate"></link><updated>2012-05-30T11:36:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-05-30:camera-calibration-tool-update.html</id><summary type="html">&lt;p&gt;I've published new release of my Camera Calibration Tool with some bug
fixes.&lt;/p&gt;
</summary></entry><entry><title>Camera Calibration Tool</title><link href="http://www.c-vision.com.ua/camera-calibration-tool.html" rel="alternate"></link><updated>2012-05-25T18:25:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-05-25:camera-calibration-tool.html</id><summary type="html">&lt;p&gt;I've published my camera calibration tool. It is simple tool based on
OpenCV library with UI implemented with FLTK. It allow create and print
checkerboard patters with different sizes. Preview calibration images.
Save calibration results to the file. But it doesn't support
undistortion&amp;nbsp; now. It can be compiled for the Linux but CMake scripts
should be little updated.&lt;/p&gt;
</summary></entry><entry><title>Using std::vector can slowdown you program - I've made wrong conclusion</title><link href="http://www.c-vision.com.ua/using-stdvector-can-slowdown-you-program-ive-made-wrong-conclusion.html" rel="alternate"></link><updated>2012-03-14T12:08:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-03-14:using-stdvector-can-slowdown-you-program-ive-made-wrong-conclusion.html</id><summary type="html">&lt;p&gt;When you know sizes need to copy you have to use std::copy function - it
is faster for some cases even memcpy.&lt;/p&gt;
</summary></entry><entry><title>Using std::vector can slowdown you program</title><link href="http://www.c-vision.com.ua/using-stdvector-can-slowdown-you-program.html" rel="alternate"></link><updated>2012-03-13T19:35:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-03-13:using-stdvector-can-slowdown-you-program.html</id><summary type="html">&lt;p&gt;I've reviewed some code for matrices manipulation, and saw that it was
written with raw C array, I've changed it with std::vector and got big
slowdown in matrices coping. After that i wrote test program and saw
that the std::vector::assign method is very ineffective for the full
container coping, and std::vector::operator= is too ineffective than
simple memcpy(). Maybe i do something wrong? I alway thought that i can
use std::vector instead C array in C++. But now i see that i have pay
for that.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define _SECURE_SCL 0

#include &amp;quot;timer.h&amp;quot;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int main()
{
    cpptask::Timer timer;

    int arrLen = 256;
    int len = 1000000;
    {
        double* m1 = new double[arrLen];
        double* m2 = new double[arrLen];

        timer.Start();

        for(int i = 0; i &amp;lt; len; ++i)
        {
            if (i % 2)
            {
                memcpy(m1, m2, arrLen * sizeof(double));
            }
            else
            {
                memcpy(m2, m1, arrLen * sizeof(double));
            }
        }

        std::cout &amp;lt;&amp;lt; &amp;quot;Array &amp;quot; &amp;lt;&amp;lt; timer.End() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;

        delete[] m1;
        delete[] m2;
    }
    {
        std::vector&amp;lt;double&amp;gt; m1(arrLen);
        std::vector&amp;lt;double&amp;gt; m2(arrLen);

        timer.Start();

        for(int i = 0; i &amp;lt; len; ++i)
        {
            if (i % 2)
            {
                //m1.assign(m2.begin(), m2.end());
                m1 = m2;
            }
            else
            {
                m2 = m1;
                //m2.assign(m1.begin(), m1.end());
            }
        }

        std::cout &amp;lt;&amp;lt; &amp;quot;Vector &amp;quot; &amp;lt;&amp;lt; timer.End() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    }
}
&lt;/pre&gt;
</summary></entry><entry><title>x64 issue solved</title><link href="http://www.c-vision.com.ua/x64-issue-solved.html" rel="alternate"></link><updated>2012-02-15T11:56:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-02-15:x64-issue-solved.html</id><summary type="html">&lt;p&gt;Regarding my previous post I've found answer on &lt;a class="reference external" href="http://stackoverflow.com/questions/9283717/why-c-program-compiled-for-x64-platform-is-slower-than-compiled-for-x86"&gt;StackOverflow&lt;/a&gt;. There
is some issue in the Visual Studio 2010 x64 C++ compiler - it can't
handle object copy&amp;nbsp;in effective way.&lt;/p&gt;
&lt;p&gt;MSVS x64 compiler produce ineffective binary copy code, which is two
time slower then manual object copy:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;quot;timer.h&amp;quot;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

class V
{
public:
    double x;
    double y;
    double z;
};

void Test1(std::vector&amp;lt;V&amp;gt;&amp;amp; m)
{
    std::for_each(m.begin(), m.end(),
        [&amp;amp;](V&amp;amp; v)
    {
        v.x = 3.4;
        v.y = 4.66;
        v.z = 56.7;
    });
}

void Test2(std::vector&amp;lt;V&amp;gt;&amp;amp; m)
{
    std::for_each(m.begin(), m.end(),
        [&amp;amp;](V&amp;amp; v)
    {
        V v2;
        v2.x = 3.4;
        v2.y = 4.66;
        v2.z = 56.7;
        v = v2;
    });
}

int main()
{
    cpptask::Timer timer;
    std::vector&amp;lt;V&amp;gt; m(5000000);
    timer.Start();
    Test1(m);
    std::cout &amp;lt;&amp;lt; timer.End() &amp;lt;&amp;lt; std::endl;
    timer.Start();
    Test2(m);
    std::cout &amp;lt;&amp;lt; timer.End() &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/pre&gt;
&lt;p&gt;But if i add V::operator= times became the same. After analyzing
generated assemblies I saw that x64 compiler use SSEx instruction by
default in all cases, and in this case it cause time overhead.&lt;/p&gt;
</summary></entry><entry><title>C++ program compiled for x64 is slower than compiled for x86</title><link href="http://www.c-vision.com.ua/c-program-compiled-for-x64-are-slower-than-complied-for-x86.html" rel="alternate"></link><updated>2012-02-13T17:53:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2012-02-13:c-program-compiled-for-x64-are-slower-than-complied-for-x86.html</id><summary type="html">&lt;p&gt;I've wrote sample program to play with SSE optimizations. And received
some strange results:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Compiled for x64 - my SSE optimizations didn't add any significant
speed up, and some time are slower than regular code with compiler
optimizations.&lt;/li&gt;
&lt;li&gt;Compiled for x86 - my SSE optimizations give some speed up (depends
on processor). And total application execution time is much lesser
than for x64, with my optimization or without.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As i understand x64 platform can give some performance improvements only
if you work with big amounts of memory, but heavy calculations
algorithms have sense to compile&amp;nbsp; for x86.&lt;/p&gt;
&lt;p&gt;I've used Visual Studio 2010 C++ compiler on Intel Core i5-2500 3.30Ghz.&lt;/p&gt;
&lt;p&gt;But may be i make wrong conclusions?&lt;/p&gt;
&lt;p&gt;Here is code i used for testing:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;xmmintrin.h&amp;gt;

#include &amp;quot;timer.h&amp;quot;

#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

/********************DECLARATIONS************************************************/
class Vector
{
public:
    Vector():x(0),y(0),z(0){}

    Vector(double x, double y, double z)
        : x(x)
        , y(y)
        , z(z)
    {
    }

    double x;
    double y;
    double z;
};

double Dot(const Vector&amp;amp; a, const Vector&amp;amp; b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

class Vector2
{
public:
    typedef double value_type;

    Vector2():x(0),y(0){}

    Vector2(double x, double y)
        : x(x)
        , y(y)
    {
    }

    double x;
    double y;
};

/******************************TESTS***************************************************/

void Test(const std::vector&amp;lt;Vector&amp;gt;&amp;amp; m, std::vector&amp;lt;Vector2&amp;gt;&amp;amp; m2)
{
    Vector axisX(0.3f, 0.001f, 0.25f);
    Vector axisY(0.043f, 0.021f, 0.45f);

    std::vector&amp;lt;Vector2&amp;gt;::iterator i2 = m2.begin();

    std::for_each(m.begin(), m.end(),
        [&amp;amp;](const Vector&amp;amp; v)
    {
        Vector2 r(0,0);
        r.x = Dot(axisX, v);
        r.y = Dot(axisY, v);

        (*i2) = r;
        ++i2;
    });
}

void TestSIMD(const std::vector&amp;lt;Vector&amp;gt;&amp;amp; m, std::vector&amp;lt;Vector2&amp;gt;&amp;amp; m2)
{
    Vector axisX(0.3f, 0.001f, 0.25f);
    Vector axisY(0.043f, 0.021f, 0.45f);

    __m128d ax = _mm_set_pd(axisX.x, axisY.x);
    __m128d ay = _mm_set_pd(axisX.y, axisY.y);
    __m128d az = _mm_set_pd(axisX.z, axisY.z);

    std::vector&amp;lt;Vector2&amp;gt;::iterator i2 = m2.begin();

    std::for_each(m.begin(), m.end(),
        [&amp;amp;](const Vector&amp;amp; v)
    {
        __m128d x = _mm_set_pd(v.x, v.x);
        __m128d y = _mm_set_pd(v.y, v.y);
        __m128d z = _mm_set_pd(v.z, v.z);

        __m128d xx = _mm_mul_pd(x, ax);
        __m128d yy = _mm_mul_pd(y, ay);
        __m128d zz = _mm_mul_pd(z, az);

        __m128d xy = _mm_add_pd(xx, yy);
        __m128d xyz = _mm_add_pd(xy, zz);

        _mm_storeh_pd(&amp;amp;(*i2).x, xyz);
        _mm_storel_pd(&amp;amp;(*i2).y, xyz);
        ++i2;
    });
}

int main()
{
    cpptask::Timer timer;

    int len2 = 300;
    size_t len = 5000000;
    std::vector&amp;lt;Vector&amp;gt; m;
    m.reserve(len);
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        m.push_back(Vector(i * 0.2345, i * 2.67, i * 0.98));
    }

    /***********************************************************************************/
    {
        std::vector&amp;lt;Vector2&amp;gt; m2(m.size());
        double time = 0;
        for (int i = 0; i &amp;lt; len2; ++i)
        {
            timer.Start();
            Test(m, m2);
            time += timer.End();
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;Dot product double - &amp;quot; &amp;lt;&amp;lt; time / len2 &amp;lt;&amp;lt; std::endl;
    }
    /***********************************************************************************/
    {
        std::vector&amp;lt;Vector2&amp;gt; m2(m.size());
        double time = 0;
        for (int i = 0; i &amp;lt; len2; ++i)
        {
            timer.Start();
            TestSIMD(m, m2);
            time += timer.End();
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;Dot product SIMD double - &amp;quot; &amp;lt;&amp;lt;  time / len2 &amp;lt;&amp;lt; std::endl;
    }
    /***********************************************************************************/

    return 0;
}
&lt;/pre&gt;
</summary></entry><entry><title>Integer overflow</title><link href="http://www.c-vision.com.ua/integer-overflow.html" rel="alternate"></link><updated>2011-11-29T16:51:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2011-11-29:integer-overflow.html</id><summary type="html">&lt;p&gt;It have sense to never user clear unsigned types in loops in your
program to avoid&amp;nbsp; overflow situation. But if you need big numbers range
from unsigned types, you can use wrappers like &lt;a class="reference external" href="http://safeint.codeplex.com/"&gt;SafeInt&lt;/a&gt;. Good article
how to use it you can find &lt;a class="reference external" href="http://msdn.microsoft.com/en-us/library/ms972705"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And little example for VisualStudio:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;limits&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;safeint.h&amp;gt;

typedef unsigned long DWORD;

using namespace std;

void CheckOverflow(DWORD val)
{
    if (val == numeric_limits&amp;lt;DWORD&amp;gt;::max())
    {
        cout &amp;lt;&amp;lt; &amp;quot;overflow\n&amp;quot;;
    }
    else
    {
        cout &amp;lt;&amp;lt; &amp;quot;ok\n&amp;quot;;
    }
}

int main()
{
    DWORD val = -1;

    cout &amp;lt;&amp;lt; &amp;quot;-1\n&amp;quot;;
    CheckOverflow(val);

    val = -2;
    cout &amp;lt;&amp;lt; &amp;quot;-2\n&amp;quot;;
    CheckOverflow(val);

    int v = -2;
    msl::utilities::SafeInt&amp;lt;DWORD&amp;gt; a(0);

    cout &amp;lt;&amp;lt; &amp;quot;DWORD size: &amp;quot; &amp;lt;&amp;lt; sizeof(DWORD) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    cout &amp;lt;&amp;lt; &amp;quot;SafeInt&amp;lt;DWORD&amp;gt; size: &amp;quot; &amp;lt;&amp;lt; sizeof(msl::utilities::SafeInt&amp;lt;DWORD&amp;gt;) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;

    a = v;//raise exception

    return 0;
}
&lt;/pre&gt;
</summary><category term="Overflow"></category></entry><entry><title>Performance and memory alignment to cache line size boundaries</title><link href="http://www.c-vision.com.ua/performance-and-memory-alignment-to-cache-line-size-boundaries.html" rel="alternate"></link><updated>2011-10-05T01:56:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2011-10-05:performance-and-memory-alignment-to-cache-line-size-boundaries.html</id><summary type="html">&lt;p&gt;Here i would like to show an example of the application where you can
see that data aligned to the boundaries of cache line size is accessed
much more faster then unaligned:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;quot;timer.h&amp;quot;

#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

class A
{
public:
    int x[18];
    A* next;
};

class B
{
public:
    int x[15];
    B* next;
};

template&amp;lt;class T&amp;gt;
void TestFunc(size_t len, size_t cycles)
{
    size_t l = sizeof(T);
    std::cout &amp;lt;&amp;lt; &amp;quot;Size = &amp;quot; &amp;lt;&amp;lt; l &amp;lt;&amp;lt; std::endl;

    T* m = new T[len];
    for(size_t i = 0; i &amp;lt; len; ++i)
    {
        m[i].next = 0;
        if (i &amp;gt; 0)
        {
            m[i - 1].next = &amp;amp;m[i];
        }
    }
    parallel::Timer timer;
    timer.Start();
    for (size_t i = 0; i &amp;lt; cycles; ++i)
    {
        T* item = &amp;amp;m[0];
        while (item != 0)
        {
            item-&amp;gt;x[4] += 5;
            item = item-&amp;gt;next;
        }
    }
    std::cout &amp;lt;&amp;lt; cycles &amp;lt;&amp;lt; &amp;quot; cycles in &amp;quot; &amp;lt;&amp;lt; timer.End() &amp;lt;&amp;lt; &amp;quot; msn&amp;quot;;
    delete[] m;
}

int main(int /*argc*/, char* /*argv*/[])
{
    size_t len = 1024;
    size_t cycles = 5000;

    TestFunc&amp;lt;A&amp;gt;(len, cycles);
    TestFunc&amp;lt;B&amp;gt;(len, cycles);
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;Here i assume that the cache line size is 64 bytes. Also I have founded
for myself dependency between structure size and access speed - Smaller
structures are processed quickly. You can look at this example under ADM
CodeAnalyst to see that there are no data cache misses for second
function.&lt;/p&gt;
</summary><category term="Multithreading"></category></entry><entry><title>Active object and future result TBB implementation</title><link href="http://www.c-vision.com.ua/active-object-and-future-result-tbb-implementation.html" rel="alternate"></link><updated>2011-04-23T14:26:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2011-04-23:active-object-and-future-result-tbb-implementation.html</id><summary type="html">&lt;p&gt;After the reading articles about &lt;a class="reference external" href="http://drdobbs.com/cpp/226700179"&gt;future results&lt;/a&gt; and &lt;a class="reference external" href="http://drdobbs.com/go-parallel/article/showArticle.jhtml?articleID=225700095"&gt;active objects&lt;/a&gt; I have implemented a class which realize these concepts, asthreading library i used TBB. Here is a code:&lt;/p&gt;
&lt;p&gt;Active.h:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#ifndef _ACTIVE_OBJECT_H_
#define _ACTIVE_OBJECT_H_

#include &amp;quot;Types.h&amp;quot;

#include &amp;lt;functional&amp;gt;
#include &amp;lt;memory&amp;gt;

#include &amp;lt;tbb/tbb.h&amp;gt;

namespace Threading
{

template &amp;lt;class T&amp;gt;
class FutureResult
{
public:
    FutureResult()
    {
        isAvailable = false;
        haveError = false;
    }

    void SetValue(const T&amp;amp; val)
    {
        tbb::mutex::scoped_lock lock(guard);
        value = val;
        isAvailable = true;
        haveError = false;
    }

    T GetValue() const
    {
        tbb::mutex::scoped_lock lock(guard);
        isAvailable = false;
        haveError = false;
        return value;
    }

    bool IsAvailable() const
    {
        return isAvailable;
    }

    bool HaveError() const
    {
        return haveError;
    }

    std::string GetErrorReport() const
    {
        tbb::mutex::scoped_lock lock(guard);
        return errorReport;
    }

    void SetErrorReport(const std::string&amp;amp; error)
    {
        tbb::mutex::scoped_lock lock(guard);
        errorReport = error;
    }

private:
    T value;
    std::string errorReport;
    mutable tbb::atomic&amp;lt;bool&amp;gt; isAvailable;
    mutable tbb::atomic&amp;lt;bool&amp;gt; haveError;
    mutable tbb::mutex guard;
};

template &amp;lt;class R, class F, class O&amp;gt;
class FunctionRunner : public tbb::task
{
public:
    FunctionRunner(R r, F f, O* p)
        : result(r)
        , func(f)
        , ptr(p)
    {}
    virtual task* execute()
    {
        try
        {
            result-&amp;gt;SetValue((ptr-&amp;gt;*func)());
        }
        catch(std::exception&amp;amp; e)
        {
            result-&amp;gt;SetErrorReport(e.what());
        }
        return 0;
    }
    R result;
    F func;
    O* ptr;
};

class Active

{

public:

    Active();

    ~Active();

    template&amp;lt;class R, class F, class O&amp;gt;

    std::shared_ptr&amp;lt;FutureResult&amp;lt;R&amp;gt; &amp;gt; ExecuteParallel(F f, O* p)

    {

        std::shared_ptr&amp;lt;FutureResult&amp;lt;R&amp;gt; &amp;gt; result(new FutureResult&amp;lt;R&amp;gt;());

        tbb::task&amp;amp; tbbTask = *(new(parent-&amp;gt;allocate_child())

                               FunctionRunner&amp;lt;decltype(result),F,O&amp;gt;(result, f, p));

        parent-&amp;gt;increment_ref_count();

        parent-&amp;gt;spawn(tbbTask);

        return result;

    }

    void WaitAll() const;

private:

    Active(const Active&amp;amp;);

    void operator= (const Active&amp;amp;);

private:

    tbb::empty_task* parent;

};

}

#endif
&lt;/pre&gt;
&lt;p&gt;Active.cpp:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;quot;Active.h&amp;quot;

namespace Threading
{
/*******************************************************************************/
Active::Active()

{

    parent = new( tbb::task::allocate_root() ) tbb::empty_task;

    parent-&amp;gt;set_ref_count(1);

}

/*******************************************************************************/

Active::~Active()

{

    parent-&amp;gt;wait_for_all();
    parent-&amp;gt;destroy(*parent);

}
/*******************************************************************************/
void Active::WaitAll() const
{
    parent-&amp;gt;wait_for_all();
    parent-&amp;gt;set_ref_count(1);
}
/*******************************************************************************/
}
&lt;/pre&gt;
</summary><category term="Multithreading"></category></entry><entry><title>Debug STL with GDB</title><link href="http://www.c-vision.com.ua/debug-stl-with-gdb.html" rel="alternate"></link><updated>2011-01-26T06:15:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2011-01-26:debug-stl-with-gdb.html</id><summary type="html">&lt;div&gt;&lt;p&gt;I've found very useful script for viewing STL containers under GDB here
is &lt;a class="reference external" href="http://help.lockergnome.com/linux/GDB-capabilities-exploring-STL-classes--ftopict279673.html"&gt;link&lt;/a&gt;. Also i duplicated them here :&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;pre class="literal-block"&gt;
##########################################
# #
# STL GDB evaluators/views/utilities #
# #
##########################################
#
# The new GDB commands:
# are entirely non instrumental
# do not depend on any &amp;quot;inline&amp;quot;(s) - e.g. size(), [], etc
# are extremely tolerant to debugger settings
#
# This file should be &amp;quot;included&amp;quot; in .gdbinit as following:
# source stl-views.gdb or just paste it into your .gdbinit file
#
# The following STL containers are currently supported:
#
# std::vector -- via pvector command
# std::list -- via plist command
# std::map -- via pmap command
# std::multimap -- via pmap command
# std::set -- via pset command
# std::multiset -- via pset command
# std::deque -- via pdequeue command
# std::stack -- via pstack command
# std::queue -- via pqueue command
# std::priority_queue -- via ppqueue command
# std::bitset -- via pbitset command
# std::string -- via pstring command
# std::widestring -- via pwstring command
#
# The end of this file contains (optional) C++ beautifiers
#
##########################################################################
# #
# CopyRight &amp;#64; 2008 - Dan C Marinescu - All Rights Reserved under GPL V3. #
# #
# Email: dan_c_marinescu.RemoveThis&amp;#64;yahoo.com #
# #
##########################################################################

#
# std::vector&amp;lt;&amp;gt;
#

define pvector
if $argc == 0
help pvector
else
set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start
set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start
set $size_max = $size - 1
end
if $argc == 1
set $i = 0
while $i &amp;lt; $size printf &amp;quot;elem[%u]: &amp;quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end if $argc == 2 set $idx = $arg1 if $idx &amp;lt; 0 || $idx &amp;gt; $size_max
printf &amp;quot;idx1, idx2 are not in acceptable range: [0..%u].n&amp;quot;, $size_max
else
printf &amp;quot;elem[%u]: &amp;quot;, $idx
p *($arg0._M_impl._M_start + $idx)
end
end
if $argc == 3
set $start_idx = $arg1
set $stop_idx = $arg2
if $start_idx &amp;gt; $stop_idx
set $tmp_idx = $start_idx
set $start_idx = $stop_idx
set $stop_idx = $tmp_idx
end
if $start_idx &amp;lt; 0 || $stop_idx &amp;lt; 0 || $start_idx &amp;gt; $size_max || $stop_idx &amp;gt; $size_max
printf &amp;quot;idx1, idx2 are not in acceptable range: [0..%u].n&amp;quot;, $size_max
else
set $i = $start_idx
while $i &amp;lt;= $stop_idx printf &amp;quot;elem[%u]: &amp;quot;, $i p *($arg0._M_impl._M_start + $i) set $i++ end end end if $argc &amp;gt; 0
printf &amp;quot;Vector size = %un&amp;quot;, $size
printf &amp;quot;Vector capacity = %un&amp;quot;, $capacity
printf &amp;quot;Element &amp;quot;
whatis $arg0._M_impl._M_start
end
end

document pvector
Prints std::vector information.
Syntax: pvector
Note: idx, idx1 and idx2 must be in acceptable range [0...size()-1].
Examples:
pvector v - Prints vector content, size, capacity and T typedef
pvector v 0 - Prints element[idx] from vector
pvector v 1 2 - Prints elements in range [idx1..idx2] from vector
end

#
# std::list&amp;lt;&amp;gt;
#

define plist
if $argc == 0
help plist
else
set $head = &amp;amp;$arg0._M_impl._M_node
set $current = $arg0-&amp;gt;_M_impl-&amp;gt;_M_node-&amp;gt;_M_next
set $size = 0
while $current != $head
if $argc == 2
printf &amp;quot;elem[%u]: &amp;quot;, $size
p *($arg1*)($current + 1)
end
if $argc == 3
if $size == $arg2
printf &amp;quot;elem[%u]: &amp;quot;, $size
p *($arg1*)($current + 1)
end
end
set $current = $current-&amp;gt;_M_next
set $size++
end
printf &amp;quot;List size = %u n&amp;quot;, $size
if $argc == 1
printf &amp;quot;List &amp;quot;
whatis $arg0
printf &amp;quot;Use plist to see the elements in the list.n&amp;quot;
end
end
end

document plist
Prints std::list information.
Syntax: plist : Prints list size, if T defined all elements or just element at idx
Examples:
plist l - prints list size and definition
plist l int - prints all elements and list size
plist l int 2 - prints the third element in the list (if exists) and list size
end

#
# std::map and std::multimap
#

define pmap
if $argc == 0
help pmap
else
set $tree = $arg0
set $i = 0
set $node = $tree-&amp;gt;_M_t-&amp;gt;_M_impl-&amp;gt;_M_header-&amp;gt;_M_left
set $end = $tree-&amp;gt;_M_t-&amp;gt;_M_impl-&amp;gt;_M_header
set $tree_size = $tree-&amp;gt;_M_t-&amp;gt;_M_impl-&amp;gt;_M_node_count
if $argc == 1
printf &amp;quot;Map &amp;quot;
whatis $tree
printf &amp;quot;Use pmap to see the elements in the map.n&amp;quot;
end
if $argc == 3
while $i &amp;lt; $tree_size set $value = (void *)($node + 1) printf &amp;quot;elem[%u]-&amp;gt;left: &amp;quot;, $i
p *($arg1*)$value
set $value = $value + 4
printf &amp;quot;elem[%u]-&amp;gt;right: &amp;quot;, $i
p *($arg2*)$value
if $node-&amp;gt;_M_right != 0
set $node = $node-&amp;gt;_M_right
while $node-&amp;gt;_M_left != 0
set $node = $node-&amp;gt;_M_left
end
else
set $tmp_node = $node-&amp;gt;_M_parent
while $node == $tmp_node-&amp;gt;_M_right
set $node = $tmp_node
set $tmp_node = $tmp_node-&amp;gt;_M_parent
end
if $node-&amp;gt;_M_right != $tmp_node
set $node = $tmp_node
end
end
set $i++
end
end
if $argc == 4
set $idx = $arg3
set $ElementsFound = 0
while $i &amp;lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &amp;quot;elem[%u]-&amp;gt;left: &amp;quot;, $i
p *($arg1*)$value
set $value = $value + 4
printf &amp;quot;elem[%u]-&amp;gt;right: &amp;quot;, $i
p *($arg2*)$value
set $ElementsFound++
end
if $node-&amp;gt;_M_right != 0
set $node = $node-&amp;gt;_M_right
while $node-&amp;gt;_M_left != 0
set $node = $node-&amp;gt;_M_left
end
else
set $tmp_node = $node-&amp;gt;_M_parent
while $node == $tmp_node-&amp;gt;_M_right
set $node = $tmp_node
set $tmp_node = $tmp_node-&amp;gt;_M_parent
end
if $node-&amp;gt;_M_right != $tmp_node
set $node = $tmp_node
end
end
set $i++
end
printf &amp;quot;Number of elements found = %un&amp;quot;, $ElementsFound
end
if $argc == 5
set $idx1 = $arg3
set $idx2 = $arg4
set $ElementsFound = 0
while $i &amp;lt; $tree_size set $value = (void *)($node + 1) set $valueLeft = *($arg1*)$value set $valueRight = *($arg2*)($value + 4) if $valueLeft == $idx1 &amp;amp;&amp;amp; $valueRight == $idx2 printf &amp;quot;elem[%u]-&amp;gt;left: &amp;quot;, $i
p $valueLeft
printf &amp;quot;elem[%u]-&amp;gt;right: &amp;quot;, $i
p $valueRight
set $ElementsFound++
end
if $node-&amp;gt;_M_right != 0
set $node = $node-&amp;gt;_M_right
while $node-&amp;gt;_M_left != 0
set $node = $node-&amp;gt;_M_left
end
else
set $tmp_node = $node-&amp;gt;_M_parent
while $node == $tmp_node-&amp;gt;_M_right
set $node = $tmp_node
set $tmp_node = $tmp_node-&amp;gt;_M_parent
end
if $node-&amp;gt;_M_right != $tmp_node
set $node = $tmp_node
end
end
set $i++
end
printf &amp;quot;Number of elements found = %un&amp;quot;, $ElementsFound
end
printf &amp;quot;Map size = %un&amp;quot;, $tree_size
end
end

document pmap
Prints std::map or std::multimap information. Works for std::multimap as well.
Syntax: pmap : Prints map size, if T defined all elements or just element(s) with val(s)
Examples:
pmap m - prints map size and definition
pmap m int int - prints all elements and map size
pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size
pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map size
end

#
# std::set and std::multiset
#

define pset
if $argc == 0
help pset
else
set $tree = $arg0
set $i = 0
set $node = $tree-&amp;gt;_M_t-&amp;gt;_M_impl-&amp;gt;_M_header-&amp;gt;_M_left
set $end = $tree-&amp;gt;_M_t-&amp;gt;_M_impl-&amp;gt;_M_header
set $tree_size = $tree-&amp;gt;_M_t-&amp;gt;_M_impl-&amp;gt;_M_node_count
if $argc == 1
printf &amp;quot;Set &amp;quot;
whatis $tree
printf &amp;quot;Use pset to see the elements in the set.n&amp;quot;
end
if $argc == 2
while $i &amp;lt; $tree_size set $value = (void *)($node + 1) printf &amp;quot;elem[%u]: &amp;quot;, $i p *($arg1*)$value if $node-&amp;gt;_M_right != 0
set $node = $node-&amp;gt;_M_right
while $node-&amp;gt;_M_left != 0
set $node = $node-&amp;gt;_M_left
end
else
set $tmp_node = $node-&amp;gt;_M_parent
while $node == $tmp_node-&amp;gt;_M_right
set $node = $tmp_node
set $tmp_node = $tmp_node-&amp;gt;_M_parent
end
if $node-&amp;gt;_M_right != $tmp_node
set $node = $tmp_node
end
end
set $i++
end
end
if $argc == 3
set $idx = $arg2
set $ElementsFound = 0
while $i &amp;lt; $tree_size set $value = (void *)($node + 1) if *($arg1*)$value == $idx printf &amp;quot;elem[%u]: &amp;quot;, $i p *($arg1*)$value set $ElementsFound++ end if $node-&amp;gt;_M_right != 0
set $node = $node-&amp;gt;_M_right
while $node-&amp;gt;_M_left != 0
set $node = $node-&amp;gt;_M_left
end
else
set $tmp_node = $node-&amp;gt;_M_parent
while $node == $tmp_node-&amp;gt;_M_right
set $node = $tmp_node
set $tmp_node = $tmp_node-&amp;gt;_M_parent
end
if $node-&amp;gt;_M_right != $tmp_node
set $node = $tmp_node
end
end
set $i++
end
printf &amp;quot;Number of elements found = %un&amp;quot;, $ElementsFound
end
printf &amp;quot;Set size = %un&amp;quot;, $tree_size
end
end

document pset
Prints std::set or std::multiset information. Works for std::multiset as well.
Syntax: pset : Prints set size, if T defined all elements or just element(s) having val
Examples:
pset s - prints set size and definition
pset s int - prints all elements and the size of s
pset s int 20 - prints the element(s) with value = 20 (if any) and the size of s
end

#
# std::dequeue
#

define pdequeue
if $argc == 0
help pdequeue
else
set $size = 0
set $start_cur = $arg0._M_impl._M_start._M_cur
set $start_last = $arg0._M_impl._M_start._M_last
set $start_stop = $start_last
while $start_cur != $start_stop
p *$start_cur
set $start_cur++
set $size++
end
set $finish_first = $arg0._M_impl._M_finish._M_first
set $finish_cur = $arg0._M_impl._M_finish._M_cur
set $finish_last = $arg0._M_impl._M_finish._M_last
if $finish_cur &amp;lt; $finish_last set $finish_stop = $finish_cur else set $finish_stop = $finish_last end while $finish_first != $finish_stop p *$finish_first set $finish_first++ set $size++ end printf &amp;quot;Dequeue size = %un&amp;quot;, $size end end document pdequeue Prints std::dequeue information.
Syntax: pdequeue : Prints dequeue size, if T defined all elements
Deque elements are listed &amp;quot;left to right&amp;quot; (left-most stands for front and right-most stands for back)
Example:
pdequeue d - prints all elements and size of d
end

#
# std::stack
#

define pstack
if $argc == 0
help pstack
else
set $start_cur = $arg0.c._M_impl._M_start._M_cur
set $finish_cur = $arg0.c._M_impl._M_finish._M_cur
set $size = $finish_cur - $start_cur
set $i = $size - 1
while $i &amp;gt;= 0
p *($start_cur + $i)
set $i--
end
printf &amp;quot;Stack size = %un&amp;quot;, $size
end
end

document pstack
Prints std::stack information.
Syntax: pstack : Prints all elements and size of the stack
Stack elements are listed &amp;quot;top to buttom&amp;quot; (top-most element is the first to come on pop)
Example:
pstack s - prints all elements and the size of s
end

#
# std::queue
#

define pqueue
if $argc == 0
help pqueue
else
set $start_cur = $arg0.c._M_impl._M_start._M_cur
set $finish_cur = $arg0.c._M_impl._M_finish._M_cur
set $size = $finish_cur - $start_cur
set $i = 0
while $i &amp;lt; $size p *($start_cur + $i) set $i++ end printf &amp;quot;Queue size = %un&amp;quot;, $size end end document pqueue Prints std::queue information.
Syntax: pqueue : Prints all elements and the size of the queue
Queue elements are listed &amp;quot;top to bottom&amp;quot; (top-most element is the first to come on pop)
Example:
pqueue q - prints all elements and the size of q
end

#
# std::priority_queue
#

define ppqueue
if $argc == 0
help ppqueue
else
set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start
set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start
set $i = $size - 1
while $i &amp;gt;= 0
p *($arg0.c._M_impl._M_start + $i)
set $i--
end
printf &amp;quot;Priority queue size = %un&amp;quot;, $size
printf &amp;quot;Priority queue capacity = %un&amp;quot;, $capacity
end
end

document ppqueue
Prints std::priority_queue information.
Syntax: ppqueue : Prints all elements, size and capacity of the priority_queue
Priority_queue elements are listed &amp;quot;top to buttom&amp;quot; (top-most element is the first to come on pop)
Example:
ppqueue pq - prints all elements, size and capacity of pq
end

#
# std::bitset
#

define pbitset
if $argc == 0
help pbitset
else
p /t $arg0._M_w
end
end

document pbitset
Prints std::bitset information.
Syntax: pbitset : Prints all bits in bitset
Example:
pbitset b - prints all bits in b
end

#
# std::string
#

define pstring
if $argc == 0
help pstring
else
printf &amp;quot;String ttt= &amp;quot;%s&amp;quot;n&amp;quot;, $arg0._M_data()
printf &amp;quot;String size/length t= %un&amp;quot;, $arg0._M_rep()-&amp;gt;_M_length
printf &amp;quot;String capacity t= %un&amp;quot;, $arg0._M_rep()-&amp;gt;_M_capacity
printf &amp;quot;String ref-count t= %dn&amp;quot;, $arg0._M_rep()-&amp;gt;_M_refcount
end
end

document pstring
Prints std::string information.
Syntax: pstring
Example:
pstring s - Prints content, size/length, capacity and ref-count of string s
end

#
# std::wstring
#

define pwstring
if $argc == 0
help pwstring
else
call printf(&amp;quot;WString tt= &amp;quot;%ls&amp;quot;n&amp;quot;, $arg0._M_data())
printf &amp;quot;WString size/length t= %un&amp;quot;, $arg0._M_rep()-&amp;gt;_M_length
printf &amp;quot;WString capacity t= %un&amp;quot;, $arg0._M_rep()-&amp;gt;_M_capacity
printf &amp;quot;WString ref-count t= %dn&amp;quot;, $arg0._M_rep()-&amp;gt;_M_refcount
end
end

document pwstring
Prints std::wstring information.
Syntax: pwstring
Example:
pwstring s - Prints content, size/length, capacity and ref-count of wstring s
end

#
# C++ related beautifiers
#

set print pretty on
set print object on
set print static-members on
set print vtbl on
set print demangle on
set demangle-style gnu-v3
set print sevenbit-strings off
&lt;/pre&gt;
&lt;/div&gt;</summary></entry><entry><title>False sharing</title><link href="http://www.c-vision.com.ua/19.html" rel="alternate"></link><updated>2010-11-23T09:10:00+02:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-11-23:19.html</id><summary type="html">&lt;p&gt;Here is &amp;quot;False sharing&amp;quot; example, you can try it in VS with enabled
OpenMP flag. Also if you enable speed optimization for compiler single
thread version will be faster, but you can see false sharing effect too.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;omp.h&amp;gt;

using std::cout;
using std::endl;

const double M=8e8;

//single thread work to do
void one_thread()
{
    long int n1=1, n2=1;
    for(; n1&amp;lt;M; n1+=n1%3);
    for(; n2&amp;lt;M; n2+=n2%3);
    cout &amp;lt;&amp;lt; &amp;quot;Sum = &amp;quot; &amp;lt;&amp;lt; n1 + n2 &amp;lt;&amp;lt; endl;
}

//multi thread work to do
void multi_thread()
{
    struct T
    {
        long int n1;
        char chuck[64];//should be commented to see false sharing effect
        long int n2;
    } t;
    t.n1 = 1;
    t.n2 = 1;
    #pragma omp parallel num_threads(2) shared(M,t)
    {
        #pragma omp sections
        {
            #pragma omp section
            for(; t.n1&amp;lt;M; t.n1+=t.n1%3);

            #pragma omp section
            for(; t.n2&amp;lt;M; t.n2+=t.n2%3);
        }
    }
    cout &amp;lt;&amp;lt; &amp;quot;Sum = &amp;quot; &amp;lt;&amp;lt; t.n1 + t.n2 &amp;lt;&amp;lt; endl;
}

time_t start, end;
double diff;

int main(int argc, char* argv[])
{
    time(&amp;amp;start);
    multi_thread();
    time(&amp;amp;end);
    diff=difftime(end, start);
    cout&amp;lt;&amp;lt;diff&amp;lt;&amp;lt;&amp;quot; seconds elapsed for multi thread calculation.&amp;quot;&amp;lt;&amp;lt;endl;

    time(&amp;amp;start);
    one_thread();
    time(&amp;amp;end);
    diff=difftime(end, start);
    cout&amp;lt;&amp;lt;diff&amp;lt;&amp;lt;&amp;quot; seconds elapsed for 1 thread calculation.&amp;quot;&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/pre&gt;
</summary><category term="Multithreading"></category></entry><entry><title>Again about rvalues</title><link href="http://www.c-vision.com.ua/again-about-rvalues.html" rel="alternate"></link><updated>2010-08-12T03:32:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-08-12:again-about-rvalues.html</id><summary type="html">&lt;p&gt;You can use rvalues for creating move semantics - remove copy
constructors for temporaries. Example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;iostream&amp;gt;

class A
{
public:
    A()
    {
        x = new int[1];
        x[0] = 1;
        std::cout &amp;lt;&amp;lt; &amp;quot;newn&amp;quot;;
    }
    ~A()
    {
        delete[] x;
    }

    A(const A&amp;amp; a)
    {
        x = new int[1];
        x[0] = a.x[0];
        std::cout &amp;lt;&amp;lt; &amp;quot;newn&amp;quot;;
    }

   /* A(A&amp;amp;&amp;amp; a) //move constructor
    {
        x = a.x;
        a.x = 0;
    }*/
private:
    int *x;
};

A GetA()
{
    A a;
    return a;
}
&lt;/pre&gt;
</summary></entry><entry><title>C++0x multi-threading</title><link href="http://www.c-vision.com.ua/c0x-multi-threading.html" rel="alternate"></link><updated>2010-06-03T02:30:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-06-03:c0x-multi-threading.html</id><summary type="html">&lt;p&gt;If you want to play with new functionality for multi-threading in C++
for free you need gcc-4.5 and Linux, MinGW currently doesn't support
this functionality (but it has all required headers). To compile
programm you need to specify complier flag -std=c++0x and linker flag
-pthread. VC++ currently have not this functionality too. Here is small
example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;mutex&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

class MyJob
{
public:
    MyJob(std::mutex* m) : m(m){}
    void operator()()
    {
        for (int i = 0; i &amp;lt; 5; ++i)
        {
            {
                std::lock_guard&amp;lt;std::mutex&amp;gt; lock(*m);
                std::thread::id id = std::this_thread::get_id();
                std::cout &amp;lt;&amp;lt; &amp;quot;Thread &amp;quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; std::endl;
            }
            sleep(1);
        }
    }
private:
    std::mutex* m;
};

int main()
{
    std::mutex m;
    std::thread t1{MyJob(&amp;amp;m)};
    std::thread t2{MyJob(&amp;amp;m)};

    t1.join();
    t2.join();

    return 0;
}
&lt;/pre&gt;
</summary><category term="C++11"></category></entry><entry><title>FLTK Fluid horisontal widgets</title><link href="http://www.c-vision.com.ua/fltk-fluid-horisontal-widgets.html" rel="alternate"></link><updated>2010-05-13T12:12:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-05-13:fltk-fluid-horisontal-widgets.html</id><summary type="html">&lt;p&gt;If you want to make some widget in FLTK horizontal you have to go to the
c++ properties:&lt;/p&gt;
&lt;img alt="image" src="images/fluid.jpg" /&gt;
</summary></entry><entry><title>CMake + VC++2010</title><link href="http://www.c-vision.com.ua/cmake-vc2010.html" rel="alternate"></link><updated>2010-04-27T07:53:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-04-27:cmake-vc2010.html</id><summary type="html">&lt;p&gt;There is now the bug in CMake 2.8.1 with Visual Studio 2010 Express -
compiler checks doesn't work. Here is
&lt;a class="reference external" href="http://www.itk.org/Bug/view.php?id=10539"&gt;http://www.itk.org/Bug/view.php?id=10539&lt;/a&gt; patch for this bug.&lt;/p&gt;
</summary></entry><entry><title>Time convertions with daylight saving</title><link href="http://www.c-vision.com.ua/time-convertions-with-daylight-saving.html" rel="alternate"></link><updated>2010-04-20T09:21:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-04-20:time-convertions-with-daylight-saving.html</id><summary type="html">&lt;p&gt;I've found how to convert time from UTC to local time with daylight saving correction:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Use mktime() to create time from string(or some thing else)&lt;/li&gt;
&lt;li&gt;get time from gmtime() and localtime()&lt;/li&gt;
&lt;li&gt;calculate difference between time to get timezone offset (or use_get_timezone)&lt;/li&gt;
&lt;li&gt;use tm::tm_isdst to determine apply or not daylight saving&lt;/li&gt;
&lt;li&gt;use _get_daylight() to get value in hours of daylight correction.&lt;/li&gt;
&lt;/ol&gt;
</summary></entry><entry><title>Online compiler</title><link href="http://www.c-vision.com.ua/online-compiler.html" rel="alternate"></link><updated>2010-04-19T14:32:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-04-19:online-compiler.html</id><summary type="html">&lt;p&gt;Here is &lt;a class="reference external" href="http://codepad.org/"&gt;codepad&lt;/a&gt; cool on-line compiler&lt;/p&gt;
</summary></entry><entry><title>Perfect forwarding full example</title><link href="http://www.c-vision.com.ua/perfect-forwarding-full-example.html" rel="alternate"></link><updated>2010-04-18T09:45:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-04-18:perfect-forwarding-full-example.html</id><summary type="html">&lt;p&gt;Here is an example of how to use rvalue references for forwarding:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

class V
{
public:
    explicit V(int x) :x(x)
    {
       &amp;nbsp;std::cout &amp;lt; &amp;lt;  &amp;quot;V()n&amp;quot;;
    }
    int x;
protected:
   &amp;nbsp;V(const V&amp;amp;){}
   &amp;nbsp;V&amp;amp; operator=(const V&amp;amp;){}
};

class A
{
public:
    A(V&amp;amp; v)
    {
       &amp;nbsp;std::cout &amp;lt; &amp;lt;  &amp;quot;A(V&amp;amp;) x = &amp;quot; &amp;lt; &amp;lt;  v.x &amp;lt; &amp;lt;  &amp;quot;n&amp;quot;;
    }
};

template&amp;lt; typename T, typename Arg&amp;gt; std::shared_ptr&amp;lt; T&amp;gt; factory(Arg arg)
{
    return std::shared_ptr&amp;lt; T&amp;gt;(new T(arg));
}

template&amp;lt; typename T, typename Arg&amp;gt; std::shared_ptr&amp;lt; T&amp;gt; factory2(Arg&amp;amp;&amp;amp; arg)
{
    // you can't use std::move for forwarding - compiler error
    return std::shared_ptr&amp;lt; T&amp;gt;(new T(std::forward&amp;lt; V&amp;gt;(arg)));
}

int main(int argc, char* argv[])
{
    V v(1);

    A a(v);

   // compiler error //std::shared_ptr a1 = factory(v);

    std::shared_ptr&amp;lt; A&amp;gt; a1 = factory2&amp;lt; A&amp;gt;(v);

    return 0;
}
&lt;/pre&gt;
</summary><category term="C++11"></category></entry><entry><title>Practical example of Rvalue references and move semantics</title><link href="http://www.c-vision.com.ua/practical-example-of-rvalue-references-and-move-semantics.html" rel="alternate"></link><updated>2010-04-18T09:16:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-04-18:practical-example-of-rvalue-references-and-move-semantics.html</id><summary type="html">&lt;p&gt;Here is simple example how to use move semantics to optimize you code -
you can override + operator to reduce constructor numbers:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class A
{
public:
    A(int x)
      : x(x)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;A(int x)\n&amp;quot;;
    }

    A(const A&amp;amp; a)
       : x(a.x)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;A(const A&amp;amp;)\n&amp;quot;;
    }

    A&amp;amp; operator=(const A&amp;amp; a)
    {
        x = a.x;
        return *this;
    }

    A operator+(const A&amp;amp; a)
    {
        return A(x + a.x);
    }

private:
    int x;
};

class B
{
public:
    B(int x)
       : x(x)
    {
        std::cout &amp;lt;&amp;lt;  &amp;quot;B(int x)\n&amp;quot;;
    }

    B(const B&amp;amp;amp; b)
       : x(b.x)
    {
        std::cout &amp;lt;&amp;lt;  &amp;quot;B(const B&amp;amp;)\n&amp;quot;;
    }

    B(B&amp;amp;&amp;amp; b)
       : x(std::move(b.x))
    {
        std::cout &amp;lt;&amp;lt;  &amp;quot;B(B&amp;amp;&amp;amp;)\n&amp;quot;;
    }

    B&amp;amp;; operator=(const B&amp;amp; b)
    {
        x = b.x;
        return *this;
    }

    B&amp;amp; operator=(B&amp;amp;&amp;amp; b)
    {
        x = std::move(b.x);
        return *this;
    }

    B operator+(const B&amp;amp; b)
    {
        return B(x + b.x);
    }

    B&amp;amp;&amp;amp; operator+(B&amp;amp;&amp;amp; b)
    {
        b.x += x;
        return std::move(b);
    }

private:
    int x;
};

int main(int argc, char* argv[])
{
    A a1(5);
    A a2 = a1 + 2 + 3;

    B b1(5);
    B b2 = b1 + 2 + 3;
    return 0;
}
&lt;/pre&gt;
</summary><category term="C++11"></category></entry><entry><title>Simple unit test framework for C++</title><link href="http://www.c-vision.com.ua/simple-unit-test-framework-for-c.html" rel="alternate"></link><updated>2010-04-16T07:06:00+03:00</updated><author><name>kirill</name></author><id>tag:www.c-vision.com.ua,2010-04-16:simple-unit-test-framework-for-c.html</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;I want to create very simple unit test framework for C++ which can be used with Visual Studio. I mean that it must have some integration to IDE. When i searched&amp;nbsp; for some existent frameworks i didn't find anything useful and open source. Also i want this framework should be very lightweight, and test creation  should take very little time, because instead test creation doesn't have sense.&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;So here is first version, it use new features from C++0x, and was created in Visual Studio2010 Express.It produce output to standard Output window, and you can click on failed assertion message to move you code editor to required code line.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Test.h:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#pragma once

#include &amp;lt; sstream&amp;gt;

#define CHECK(v) self-&amp;gt;Assert(##v, L#v, __FILE__, __LINE__);

#define CHECK_EQUALS(v1, v2) self-&amp;gt;AssertEquals(##v1,##v2, L#v1, L#v2, __FILE__, __LINE__);

#define CHECK_NOT_EQUALS(v1, v2) self-&amp;gt;AssertNotEquals(##v1,##v2, L#v1, L#v2, __FILE__, __LINE__);

#define TEST(name) void name(testengine::Test* self)

namespace testengine
{
&amp;nbsp;&amp;nbsp;&amp;nbsp; class Test
&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp; public:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Test() : done(true) {self = this;}
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual ~Test(){}
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void Setup(){}
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void TearDown(){}
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; virtual void Run() = 0;

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; void Assert(bool rez, const std::wstring&amp;amp; msg, const std::string&amp;amp; fileName, size_t line)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (!rez)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; std::wstringstream buf;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; buf &amp;lt; &amp;lt;&amp;nbsp; fileName.c_str() &amp;lt; &amp;lt;&amp;nbsp; L&amp;quot;(&amp;quot; &amp;lt; &amp;lt;&amp;nbsp; line &amp;lt; &amp;lt;&amp;nbsp; &amp;quot;) : Assertation failed : &amp;quot; &amp;lt; &amp;lt;&amp;nbsp; msg.c_str() &amp;lt; &amp;lt;&amp;nbsp; std::endl;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; report += buf.str();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; done = false;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; template &amp;lt; class T1, class T2&amp;gt; void AssertEquals(T1 v1, T2 v2, const std::wstring&amp;amp; msg1, const std::wstring&amp;amp; msg2, const std::string&amp;amp; fileName, size_t line)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; std::wstringstream buf;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; buf &amp;lt; &amp;lt;&amp;nbsp; msg1 &amp;lt; &amp;lt;&amp;nbsp; L&amp;quot; == &amp;quot; &amp;lt; &amp;lt;&amp;nbsp; msg2;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Assert(v1 == v2, buf.str(), fileName, line);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; template &amp;lt; class T1, class T2&amp;gt; void AssertNotEquals(T1 v1, T2 v2, const std::wstring&amp;amp; msg1, const std::wstring&amp;amp; msg2, const std::string&amp;amp; fileName, size_t line)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; std::wstringstream buf;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; buf &amp;lt; &amp;lt;&amp;nbsp; msg1 &amp;lt; &amp;lt;&amp;nbsp; L&amp;quot; != &amp;quot; &amp;lt; &amp;lt;&amp;nbsp; msg2;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Assert(v1 != v2, buf.str(), fileName, line);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; const std::wstring GetReport() {return report;}

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool IsDone() {return done;}
&amp;nbsp;&amp;nbsp;&amp;nbsp; protected:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Test* self;
&amp;nbsp;&amp;nbsp;&amp;nbsp; private:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; std::wstring report;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool done;
&amp;nbsp;&amp;nbsp;&amp;nbsp; };
}
&lt;/pre&gt;
&lt;p&gt;TestExecuter.h:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#pragma once

#include &amp;quot;Test.h&amp;quot;

#include &amp;lt;memory&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;tuple&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;functional&amp;gt;

#include &amp;lt; windows.h&amp;gt;

namespace testengine
{
typedef std::function&amp;lt; void(Test*)&amp;gt; TestFunction;

class SingleFunctionTest : public Test
{
public:
    SingleFunctionTest(TestFunction func) : func(func){} virtual void Run()
    {
        func(this);
    }

private:
    TestFunction func;
};

class TestExecuter
{
public:
    void AddTest(TestFunction func, const std::wstring&amp;amp; name)
    {
        tests.push_back(std::make_tuple(name, new SingleFunctionTest(func)));
    }

    template&amp;lt; class T&amp;gt; void AddTest(const std::wstring&amp;amp; name)
    {
        tests.push_back(std::make_tuple(name, new T));
    }

    void RunTests()
    {
        OutputDebugStringW(L&amp;quot;=============================================================================n&amp;quot;);
        OutputDebugStringW(L&amp;quot;Start running tests :n&amp;quot;);
        auto i = tests.begin(), e = tests.end();
        size_t passed = 0;
        size_t failed = 0;
        for (;i != e; ++i)
        {
            OutputDebugStringW(L&amp;quot;-----------------------------------------------------------------------------n&amp;quot;);
            bool go = true;
            std::wstringstream buf;
            buf &amp;lt; &amp;lt;  std::get&amp;lt; 0&amp;gt;(*i);
            try
            {
                std::get&amp;lt; 1&amp;gt;(*i)-&amp;gt;Setup();
            }
            catch(...)
            {
                buf &amp;lt; &amp;lt;  L&amp;quot; - Fails : Unhandled exception while Setupn&amp;quot;;
                OutputDebugStringW(buf.str().c_str());
                go = false; ++failed;
            }

            if (go)
            {
                try { std::get&amp;lt; 1&amp;gt;(*i)-&amp;gt;Run();
            }
            catch(...)
            {
                buf &amp;lt; &amp;lt;  L&amp;quot; - Fails : Unhandled exception while Runn&amp;quot;;
                OutputDebugStringW(buf.str().c_str());
                go = false; ++failed;
            }
        }
        if (go)
        {
            try
            {
                std::get&amp;lt; 1&amp;gt;(*i)-&amp;gt;TearDown();
            }
            catch(...)
            {
                buf &amp;lt; &amp;lt;  L&amp;quot; - Fails : n&amp;quot;;
                buf &amp;lt; &amp;lt;  std::get&amp;lt; 1&amp;gt;(*i)-&amp;gt;GetReport();
                buf &amp;lt; &amp;lt;  L&amp;quot;Unhandled exception while TearDownn&amp;quot;;
                OutputDebugStringW(buf.str().c_str());
                go = false; ++failed;
            }
        }

        if (go)
        {
            if (!std::get&amp;lt; 1&amp;gt;(*i) -&amp;gt;IsDone())
            {
                buf &amp;lt; &amp;lt;  L&amp;quot; - Fails : n&amp;quot; &amp;lt; &amp;lt;  std::get&amp;lt; 1&amp;gt;(*i)-&amp;gt;GetReport();
                OutputDebugStringW(buf.str().c_str());
                ++failed;
            }
            else
            {
                buf &amp;lt; &amp;lt;  L&amp;quot; - OKn&amp;quot;;
                OutputDebugStringW(buf.str().c_str()); ++passed;
            }
        }
    }
    OutputDebugStringW(L&amp;quot;-----------------------------------------------------------------------------n&amp;quot;);
    std::wstringstream buf;
    buf &amp;lt; &amp;lt;  L&amp;quot;All tests finished : passed = &amp;quot; &amp;lt; &amp;lt;  passed &amp;lt; &amp;lt;  L&amp;quot; failed = &amp;quot; &amp;lt; &amp;lt;  failed &amp;lt; &amp;lt;  std::endl;
    OutputDebugStringW(buf.str().c_str());
    OutputDebugStringW(L&amp;quot;=============================================================================n&amp;quot;); }

private:
    std::vector&amp;lt; std::tuple&amp;lt; std::wstring, std::shared_ptr&amp;lt; Test&amp;gt; &amp;gt; &amp;gt; tests;
};
}
&lt;/pre&gt;
&lt;p&gt;main.cpp:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;quot;TestEngineTestExecuter.h&amp;quot;

class MyTest1 : public testengine::Test
{
public:
    virtual void Run()
    {
        CHECK(1 == 0);
    }
};

class MyTest2 : public testengine::Test
{
public:
    virtual void Run()
    {
        CHECK(1 == 1);
    }
};

class MyTest3 : public testengine::Test
{
public:
    virtual void Run()
    {
        CHECK_EQUALS(1, 2);
    }
};

class MyTest4 : public testengine::Test
{
public:
    virtual void TearDown()
    {
        throw 1;
    }
    virtual void Run()
    {
        CHECK_EQUALS(3, 4);
    }
};

class MyTest5 : public testengine::Test
{
public:
    virtual void Setup() { throw 1; }
    virtual void TearDown() { throw 1; }
    virtual void Run()
    {
        CHECK_EQUALS(3, 4);
    }
};

class MyTest6 : public testengine::Test
{
public:
    virtual void TearDown() { throw 1; }
    virtual void Run()
    {
        throw 1;
        CHECK_EQUALS(3, 4);
    }
};

TEST(MyTest7)
{
    CHECK_NOT_EQUALS(4, 4);
}

int main(int argc, char* argv[])
{
    testengine::TestExecuter testExec;

    testExec.AddTest&amp;lt; MyTest1&amp;gt;(L&amp;quot;MyTest1&amp;quot;);
    testExec.AddTest&amp;lt; MyTest2&amp;gt;(L&amp;quot;MyTest2&amp;quot;);
    testExec.AddTest&amp;lt; MyTest3&amp;gt;(L&amp;quot;MyTest3&amp;quot;);
    testExec.AddTest&amp;lt; MyTest4&amp;gt;(L&amp;quot;MyTest4&amp;quot;);
    testExec.AddTest&amp;lt; MyTest5&amp;gt;(L&amp;quot;MyTest5&amp;quot;);
    testExec.AddTest&amp;lt; MyTest6&amp;gt;(L&amp;quot;MyTest6&amp;quot;);
    testExec.AddTest(MyTest7, L&amp;quot;MyTest7&amp;quot;);
    testExec.RunTests();
    return 0;
 }
&lt;/pre&gt;
</summary><category term="UnitTesting"></category></entry></feed>